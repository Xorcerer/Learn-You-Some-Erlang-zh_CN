# -*- coding: UTF-8 -*-
# TODO: Make the sentences be more fluent.

什么是模块(Module)

通常认为，跟交互式shell打交道是使用动态编程语言至关重要的一环。它对于测试各种代码和程序很有用。Erlang中大部分基本数据类型都可以直接使用，甚至无需打开文本编辑器或者保存文件。你可以抛开键盘，出去打个球然后收工搞定，但是如果仅仅停留在这一步，你可能会成为一个糟糕的Erlang程序员。代码需要保存下来以备使用。

这就是模块的用途。模块是一堆函数的结合，这些函数放在一个单独名字的文件中。另外，Erlang的所有函数必须在模块中定义。或许还没意识到，你就已经使用过模块了。前一章中提到的BIFs，如 hd 和 tl，其实就是Erlang的模块，算术，逻辑和Bool运算符也都是。Erlang的模块中的BIFs不同于使用Erlang时自动导入的函数。要使用一个模块中定义的所有其他的函数，就需要通过 Module:Function(Arguments) 这样的形式。

如下所见：

    1> erlang:element(2, {a,b,c}).
    b
    2> element(2, {a,b,c}).
    b
    3> lists:seq(1,4).
    [1,2,3,4]
    4> seq(1,4).
    ** exception error: undefined shell command seq/2

这里，list 模块的 seq 函数不是自动导入的，而 element 则是。发生'undefined shell command'错误是因为，shell试图查找像 f() 这样的shell命令，但是没找到。有一些Erlang模块中的函数不会自动导入，而这些函数不会被频繁使用。

逻辑上讲，你应该把做类似事情的函数放一个单独的模块中。list的通用运算符保存在lists模块中，而用于输入输出的函数则放在io模块中。你会遇到的唯一一个不遵循该模式的模块，就是上述提到的erlang模块，这个模块有做数学，对话，处理多进程，捣鼓虚拟机设置等等。它们除了是内置函数之外，没有共同点。你应该避免创建像erlang这样的模块，而不专注于整齐的逻辑分离。



模块声明

在写模块的时候，你可以声明两件事：函数(functions) 和 属性(attributes)。属性是用于描述模块自身的元数据(metadata)，例如 名字，应该对外部可见的函数，代码的作者 等等。这种元数据很有用，因为它给编译器提示该如何工作，也因为这让人们不用参考源代码，就可以从编译过的代码中获得有用信息。

目前，全世界的Erlang代码中有大量的模块属性在被使用；事实上，你甚至可以定义任何自己想要的属性。在你的代码中，有一些预定义的属性会比其他的出现更频繁。所有的模块属性遵循这样的形式 -Name(Attribute). 。它们中只有一个对于你的模块成为可编译的是必要的:

    -module(Name).
    这总是文件中第一个属性，而且有理由这样：它是当前模块的名字，这里Name是原子(Atom)。这个模块名你将在从其他模块中调用时用到。调用时使用 M:F(A) 这样的形式，这里M是模块名，F是函数，A是参数。

是时候写代码了！我们第一个模块很简单，不过没啥用。打开文本编辑器，敲入如下内容，保存为 useless.erl:

    -module(useless).

这行是个有效的模块。真的！当然，没有函数，它没什么用。下面我们来决定可以从'useless'模块中导出的函数。为了实现这个，我们将使用另外一个属性：

    -export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity])
