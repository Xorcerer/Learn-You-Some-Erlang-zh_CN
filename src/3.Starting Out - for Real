# -*- coding: utf-8 -*-



真正的开始


Erlang是一个相对小而简单的语言（就如C相对于C++而言）。这一章将覆盖大部分Erlang为数不多基础数据类型。强烈建议阅读本章，因为它解释了你日后用Erlang写的所有程序的各个组成部分。


数字

在Erlang的Shell里，表达式需要以后面跟有空格（或者换行、#REVIEWME#）的句号“.”结束，否则他们不会被执行。你可以通过逗号“,”分隔表达式，但是只有最后一句表达式的结果会被显示（在Shell中），虽然其他同样会被执行。这对于大多数人来说，的确是不正常的语法，它源自Erlang还是被Prolog直接实现的日子，后者是一种逻辑编程语言。

以上一章介绍的方式打开Erlang的Shell，让我们开始输入一些东西。

{{{
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472.
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
}}}

你应该发现，Erlang并不在乎你是输入了一个浮点数还是整数：两种类型在算术运算时都被支持。在你的角度看，Erlang的数学运算符能无差别对待的，几乎也只有整数和浮点数了。当然，如果你需要一个“整数到整数”的除法，使用“div”，需要求模运算，使用 rem （remainder的缩写）。

注意，我们可以在同一个表达式里使用多个运算符，数学运算符遵从正常的运算顺序。

{{{
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
}}}
如果你需要表达十进制之外的整数，只要输入形如“进制数#值”（进制数在2到36之间）的数字：
{{{
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
}}}
漂亮！通过一套不可思议的语法，Erlang拥有你桌面角落上那台计算器的能力！#REVIEWME on top of it, 这里的it是什么？#绝对让人兴奋！


不可变的变量

做算术不是问题，但是如果无法保存计算结果，你就不能做太多的事情。为此，我们需要变量。如果你阅读了本书的前言，你应该知道在函数式编程语言中，变量是不能被改变的。变量的基本性质可以通过下面七个表达式来表现（请注意下面的变量都是以大写字母开头的）：
{{{
1> One.
* 1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.        
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
}}}
这些命令告诉我们的第一件事是一个变量只能被赋值一次；在它被赋值之后，你可以“假装”再赋一个同样的值给它。如果第二次赋的值不同，Erlang会抱怨的。上面的观察是正确的，但是对此的解释会复杂一点，并取决于等号“=”运算符。等号“=”运算符（而不是那些变量）拥有比较两个值和“在他们不相等的时候抱怨”的功能。如果两个值相等，它返回该值：
{{{
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
}}}
当等号“=”参与运算时，如果左边是一个未绑定（unbound）的变量（即没有被赋值），Erlang会自动把右边运算的结果复制给该变量。而接下来等号两边的比较结果显示是相同，而变量的值也会保留在内存中。
这种等号操作符的行为是’模式匹配‘的基础，后者是很多函数式编程语言拥有的特性，而比起其他语言Erlang在这一点上更有灵活和完善。我们将本章讨论元组（tuple）和列表（list）时看到模式匹配的更多细节，而接下来关于函数的章节也会提及它。
另一样命令1-7告诉我们的是变量名必须以大写字母开头。命令7报错的原因是单词“two”以一个小写开头。技术上说，变量也可以以一个下划线"_"开头，但是按照惯例，这样做仅仅适合于接受你“不需要但仍然希望注明它包含了什么”的赋值。
你也可以使用只有一个下划线的变量：
{{{
10> _ = 14+3.
17
11> _.
* 1: variable '_' is unbound
}}}

注意：如果你在Shell中测试，并且为一个变量赋一个错误的值，那么可以通过函数 f(variable). 来“擦除”这个变量。如果你希望清楚所有的变量名，使用 f(). 。
这些函数仅仅是为了帮助你测试，只能在Shell中使用。当写真正的程序的时候，我们不能通过这种方式删除值。如果你考虑到Erlang在生产环境的应用——完全有可能把一个Shell用上几年而不中断，那么它能在Shell中删除是合理的，我们可以打赌变量x会在这个期间被使用不只一次。


原子

变量名不能以小写字母开头的其中一个原因是原子的存在。原子是以自己名称的字面意思为它的值的常量。你看到的就是你得到的，没有更多内容。原子cat意思是“cat”，就这样。你不可以跟它玩#REVIEWME#（原文：You can't play with it），不可以改变它，也不可以把它分成碎片；它就是cat。
除了单个单词以小写字母开头写atom之外，我们还有别的方式：
{{{
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom
}}}
一个atom应该被单引号(')包围，如果它不是以小写字母开头或者包含了字母、数字、下划线(_)或者@之外的字符。
表达式5还表明了，一个被单引号包围的atom与把单引号去掉之后的部分是同一个原子。

我把原子以它们的名字为值的常量。你以前可能接触过使用常量的代码：举个例子，我需要为每种瞳孔的颜色确定一个值：BLUE -> 1, BROWN -> 2, GREEN -> 3, OTHER -> 4（译者：也许白人中黑色的瞳孔的比例很小）。你需要去匹配一个常量和它指代的值。原子让你抛开那些指代的值：我定义的瞳孔颜色只是简单的 blue，brown，green和other。这些颜色可以在任意代码中使用：它们指代的值永远不会有冲突，并且也不会出现变量未定义的情况！如果你真的需要有其赋值的常量，有办法可以做，我们将在[/chapter4 chapter 4（模块）]中讨论。

因此，一个原子主要用于表达或者修饰#REVIEWME#与之相连的数据。原子很难被单独使用，这就是我们没有花更多的时间讨论它的原因，它们只有在结合其他数据类型的时候，才能体现最大的价值。


不要喝太多的苦艾酒（不要想得太完美）

原子是非常适用于发送信息和表达常量。但是过度使用原子将有隐患：一个原子会被一张“原子表”引用，这导致内存上的开销（在32位系统中是每原子4字节，在64位系统中是每原子8字节）。原子表是不会被垃圾回收，所以原子会一直存在直到超过系统的限制——内存耗尽或者定义了超过1048577个原子。

这意味着不管什么原因，原子不应该动态地生成，如果你的系统需要稳定，但用户的输入导致新的原子不断生成从而导致系统崩溃，你就有大麻烦了。原子对于程序员来说应该被视为工具，坦白说，这就是原子的意义所在。


注意：一些原子是保留字，不能在语言设计者的意愿之外被使用：函数名，操作符，表达式等。它们是：after, and, andalso, band, begin, bnot, bor, bsl, bsr, bxor, case, catch, cond, div, end, fun, if, let, not, of, or, orelse, query, receive, rem, try, when, xor.


布尔代数和比较运算符

一个人会遇到麻烦如果他无法表达什么是小，什么是大，什么是真，什么是假。正如其他语言，Erlang 也让你可以使用 布尔操作和让事物做比较。

布尔单数非常简单：
{{{
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
}}}


注意：布尔运算符 and 和 or 将总会计算运算符左右两边的参数（表达式）。如果你需要短路操作（只有在需要的时候，才会计算右边的参数），使用 andalso 和 orelse。

检查相等或者不相等也非常简单，但是跟你在其他语言里看到的符号略有不同：
{{{
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
}}}

首先，你习惯的语言使用 == 和 != 来检查相等和不相等的情况，Erlang 使用 =:= 和 =/= 。最后三个表达式（第9到11行）也给我们介绍了一些潜在的细节：在做算术时，Erlang 不会关心浮点类型和整形的区别，但是在进行比较的时候会。别担心，因为 == 和 /= 运算符在这些情况（需要忽略比较对象的类型）下会帮到你。请注意你是否需要精确比较相等或者不等。

其他用于比较的运算符是 < （小于）， > （大于）， >=（大于或等于）和 =< （小于或等于）。最后一个是向前兼容的需要（在我看来），它是我源码中多处语法错误的根源。请多留心 =<。
{{{
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
}}}

如果做 5 + llama 或者 5 == true 会怎么样呢？没有什么比直接实验然后等错误信息回答你更好的办法了。
{{{
12> 5 + llama.
** exception error: bad argument in an arithmetic expression
    in operator  +/2
        called as 5 + llama
}}}
噢！Erlang 并不喜欢你这样滥用它的基础类型！模拟器会返回一个漂亮的错误信息。它告诉我们它不喜欢 + 号两边的参数的其中一个。

Erlang 并不会每次都被你弄疯掉：
{{{
13> 5 =:= true.
false
}}}
为什么它在某些运算上拒绝不同的类型，但是某些又不行呢？Erlang 不允许你随意地把两个事物相加，但是它允许你比较它们。这时因为 Erlang 的创造者们认为实用高于理论，并且倾向于可以简单的编写诸如通用的可以让任何事物有序的排序算法。它的存在就是为了在绝大多数时间里能简化你的生活。

最后一样需要注意的是，当做布尔运算和比较时：
{{{
14> 0 == false.
false
15> 1 < false.
true
}}}
也许你会抓狂，如果你来自过程式语言或者大多数面向对象语言。第14行的结果应该是 true 而15行应该是 false！因为，false 意味着0，而 true 意味着非0的任何东西！除了 Erlang。因为我骗了你。是的，我骗了你，我感到惭愧。

Erlang 并没有真正的布尔值 true 和 false。这两个对象仅仅是两个原子，只是它们在跟语言结合得很好，你在使用它们的时候不会遇到麻烦，除非你期待它们表示 false 和 true 字面意思以外的内容。

注意：在比较运算中正确的顺序是：
    number < atom < reference < fun < port < pid < tuple < list < bit string
    你还并不了解上述的所有类型，但是你将通过阅读本书了解它们。只要记得这就是为什么你可以拿任意两个对象作比较！引用 Joe Armstrong，Erlang 的创造者之一的话：“真正的顺序并不重要 —— 但是重要的是定义了一个全局的顺序。”


