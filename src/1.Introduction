前言


关于本教程

这是《自学一点Erlang》的一书的开始。这将是你学习Erlang的入门读物，所以，让我们来聊聊教程本身。

首先，我萌生写本教程的想法是在读了Miran Lipovača写的《自学一点Haskell》教程之后。我想他做了一件非常棒的事情——赋予那个语言吸引力，并且学习过程也很平滑。由于我跟他相熟，我就问他如果我写一本关于Erlang的类似的书，会怎么样。他赞成，出于他对Erlang的兴趣。

所以，我在输入这些文字。当然，我还有其他动机：我发现这门语言的入门很难（网上只有少数的文档，除此之外，你只能去买书了），并且我认为社区将从一本类似《自学一点Haskell》的书中受益。其次，我注意到一些人基于一些笼统的印象，高估或者低估了Erlang。然后有些人就很肯定Erlang名不副实。即使我希望说服他们，我也清楚他们不会第一时间读到这一段。

因此，这本书希望为那些至少是了解命令式编程语言（如，C/C++，Java，Python，Ruby等），但可能不了解函数式编程语言（Haskell，Scala，Erlang，Clojure，OCaml等）的人，提供学习Erlang的途径。我同时也希望以一种诚实的态度去写本书，在清楚地叙述Erlang的弱点和强项的基础上，推广Erlang。

那么，什么是Erlang呢？

首先，Erlang是一种函数变成语言。如果你曾结束命令式变成语言，类似 i++ 这类语句对你来说应该很常见；而在函数式编程语言，他们是不允许的。实际上，修改任何变量的值是被严格禁止的。这开始听起来可能很奇怪，但如果你记得你的数学课，这其实就是你学过的东西：

y = 2
x = y + 3
x = 2 + 3
x = 5

如果我增加下面的部分：

x = 5 + 1
x = x
∴ 5 = 6

你将觉得非常的困扰。函数式编程语言认识到这点：如果我说x是5，那么我不可能合理地声称它又是6！这并不诚实。这也是为什么一个函数，如果传入相同的参数，那么结果也应该是相同的：

x = add_two_to(3) = 5
∴ x = 5

函数总是返回相同的结果，是因为相同的参数的引用无关性（referential transparency）。
这就是为什么让我们可以把 add_two_to(3) 换成5，因为 3 + 2 的结果总会是5。这意味着我们可以把大量的函数组合起来，去解决更复杂的问题，而不会去担心出错。合理并且清晰，不是吗？但是这样仍有问题：

x = today() = 2009/10/22
    -- 一天后 --
x = today() = 2009/10/23
x = x
∴ 2009/10/22 = 2009/10/23

噢，不！我漂亮的等式！他们在瞬间出错了！为什么我的函数每天会返回不同的结果？

显然，某些有现实意义的因素，破坏了引用无关性。Erlang以实用注意的态度去实现函数式编程：遵循它最纯正的原则（引用无关性，避免出现可修改的数据等），除了跟现实世界的问题冲突的部分。

现在，我们把Erlang定义为函数式编程语言，但是需强调它的并发性和可靠性。为了让大量的任务同时被执行，Erlang使用演员模型（actor model），每一个演员都是虚拟机中的一个独立的进程。简单地说，如果你是Erlang世界里的一个演员，你会是一个孤独的人，在一个没有房间的小黑屋里，在你的信箱旁等待信件。一旦有信件传入，你将以一种指定的方式回应它：你将支付你收到的账单，你回复给你生日卡的人一封感谢信，并且你将忽略那些你读不懂的信。

Erlang的演员模型可以被想像成为一个“每个人都孤独地坐在自己的房间里去完成有限的不同的任务”的世界。每个人之间严格地只能通过信件交流，就这样。这听起来似乎是一种无聊的生活方式（又或是新一代的邮政服务），他意味着你可以要求很多人去为你执行非常特定的任务，一个人犯错不会影响到其他人的工作；他们甚至不知道除了你之外的其他人的存在。

为了做到这一点，Erlang强制你写进程不能以发送消息之外的方式与程序的其他代码共享信息。每一次交互都是显式的，可被跟踪的和安全的。

当我们定义Erlang的时候，我们是在定义一种语言，但是在更广泛的意义上，这不是它的全部：Erlang也是一个完整的开发环境（译者：这里并不包含编辑器之类的组件）。代码被编译为字节码然后在虚拟机中运行。所以Erlang，更像是Java和它的孩子们，可以运行在任何地方。标准发行版包含（但不限于）开发工具（编译器，调试器，优化工具和测试框架）、开放电信平台（Open Telecom Platform, OTP）框架，一个Web服务器，一个解析器生成器（parser generator)，和mneisa数据库——一个键-值（key-value)存储系统，可以在多个服务器之间自我复制，包含嵌套事务并可以存储任何Erlang数据。

虚拟机和相关的库让你可以在不打断任何程序的情况下更新运行中的系统的代码，方便地发布你的代码和以简单却强大的方式管理程序的错误。

我们将看到大部分这些工具的使用方式和安全的打包方法，但现在，我将向你解释一个Erlang的原则：随它崩溃（Let it crash)。这并不像是一架装有很多乘客的飞机坠毁，而更像一个在保护网之上走钢丝的人。当你需要避免错误时，在多数条件下你不需要检查每一个类型或错误的情况。

Erlang从错误中恢复的能力，以演员模式组织代码和它在发布与并发上的伸缩性听起来都很棒，这就让我们进入到了第二章......

不要喝太多～～～～

本书将会有许多节，名字就如本节一样（当你看到他的时候，你会认出它们的）。在许多热情的演讲的帮助下，Erlang正受到追捧，甚至让人对它抱有过高的期望。这类章节将帮助你回到现实，如果你也是那些过于热心的学徒之一。

第一种上述的情况，是关于Erlang在它轻量级进程的帮助下，容易被大规模扩展的特性。的确，Erlang的进程是非常的轻：你可以同时拥有数以十万记的进程，但这不代表你应该这么做——仅仅是因为你可以。比如，创建一个射击游戏时，把包括子弹在内的所有事物都作为Erlang世界里的演员是不切实际的。～～～～。演员之间传递消息仍然会有细小的开销，如果你把任务过于细分，那么你会降低执行效率。

我会进一步
