# -*- coding: UTF-8 -*-



前言


关于本教程

这是《自学一点Erlang》一书的开始。这将是你学习Erlang的入门读物，所以，让我们来聊聊教程本身。

首先，我萌生写本教程的想法是在读了Miran Lipovača写的《自学一点Haskell》教程之后。我想他做了一件非常棒的事情——赋予那个语言吸引力，并且学习过程也很平滑。由于我跟他相熟，我就问他如果我写一本关于Erlang的类似的书，会怎么样。他赞成，出于他对Erlang的兴趣。

由于前述的原因，我在输入这些文字。当然，我还有其他动机：我发现这门语言的入门很难（网上只有少数的文档，除此之外，你只能去买书了），并且我认为社区将从一本类似《自学一点Haskell》的书中受益。其次，我注意到一些人基于一些笼统的印象，高估或者低估了Erlang。然后有些人就很肯定Erlang名不副实。即使我希望说服他们，我也清楚他们不会第一时间读到这一段。

因此，这本书希望为那些至少是了解命令式编程语言（如，C/C++，Java，Python，Ruby等），但可能不了解函数式编程语言（Haskell，Scala，Erlang，Clojure，OCaml等）的人，提供学习Erlang的途径。我同时也希望以一种诚实的态度去写本书，在清楚地叙述Erlang的弱点和强项的基础上，推广Erlang。


那么，什么是Erlang呢？

首先，Erlang是一种函数变成语言。如果你曾结束命令式变成语言，类似 i++ 这类语句对你来说应该很常见；而在函数式编程语言，他们是不允许的。实际上，修改任何变量的值是被严格禁止的。这开始听起来可能很奇怪，但如果你记得你的数学课，这其实就是你学过的东西：
{{{
y = 2
x = y + 3
x = 2 + 3
x = 5
}}}
如果我增加下面的部分：
{{{
x = 5 + 1
x = x
∴ 5 = 6
}}}
你将觉得非常的困扰。函数式编程语言认识到这点：如果我说x是5，那么我不可能合理地声称它又是6！这并不诚实。这也是为什么一个函数，如果传入相同的参数，那么结果也应该是相同的：
{{{
x = add_two_to(3) = 5
∴ x = 5
}}}
函数总是返回相同的结果，是因为相同的参数的引用无关性（referential transparency）。
这就是为什么让我们可以把 add_two_to(3) 换成5，因为 3 + 2 的结果总会是5。这意味着我们可以把大量的函数组合起来，去解决更复杂的问题，而不会去担心出错。合理并且清晰，不是吗？但是这样仍有问题：
{{{
x = today() = 2009/10/22
    -- 一天后 --
x = today() = 2009/10/23
x = x
∴ 2009/10/22 = 2009/10/23
}}}
噢，不！我漂亮的等式！他们在瞬间出错了！为什么我的函数每天会返回不同的结果？

显然，某些有现实意义的因素，破坏了引用无关性。Erlang以实用注意的态度去实现函数式编程：遵循它最纯正的原则（引用无关性，避免出现可修改的数据等），除了跟现实世界的问题冲突的部分。

现在，我们把Erlang定义为函数式编程语言，但是需强调它的并发性和可靠性。为了让大量的任务同时被执行，Erlang使用演员模型（actor model），每一个演员都是虚拟机中的一个独立的进程。简单地说，如果你是Erlang世界里的一个演员，你会是一个孤独的人，在一个没有房间的小黑屋里，在你的信箱旁等待信件。一旦有信件传入，你将以一种指定的方式回应它：你将支付你收到的账单，你回复给你生日卡的人一封感谢信，并且你将忽略那些你读不懂的信。

Erlang的演员模型可以被想像成为一个“每个人都孤独地坐在自己的房间里去完成有限的不同的任务”的世界。每个人之间严格地只能通过信件交流，就这样。这听起来似乎是一种无聊的生活方式（又或是新一代的邮政服务），他意味着你可以要求很多人去为你执行非常特定的任务，一个人犯错不会影响到其他人的工作；他们甚至不知道除了你之外的其他人的存在。

为了做到这一点，Erlang强制你写进程不能以发送消息之外的方式与程序的其他代码共享信息。每一次交互都是显式的，可被跟踪的和安全的。

当我们定义Erlang的时候，我们是在定义一种语言，但是在更广泛的意义上，这不是它的全部：Erlang也是一个完整的开发环境（周翀：这里并不包含编辑器之类的组件）。代码被编译为字节码然后在虚拟机中运行。所以Erlang，更像是Java和它的孩子们，可以运行在任何地方。标准发行版包含（但不限于）开发工具（编译器，调试器，优化工具和测试框架）、开放电信平台（Open Telecom Platform, OTP）框架，一个Web服务器，一个解析器生成器（parser generator)，和mneisa数据库——一个键-值（key-value)存储系统，可以在多个服务器之间自我复制，包含嵌套事务并可以存储任何Erlang数据。

虚拟机和相关的库让你可以在不打断任何程序的情况下更新运行中的系统的代码，方便地发布你的代码和以简单却强大的方式管理程序的错误。

我们将看到大部分这些工具的使用方式和安全的打包方法，但现在，我将向你解释一个Erlang的原则：随它崩溃（Let it crash)。这并不像是一架装有很多乘客的飞机坠毁，而更像一个在保护网之上走钢丝的人。当你需要避免错误时，在多数条件下你不需要检查每一个类型或错误的情况。

Erlang从错误中恢复的能力，以演员模式组织代码和它在发布与并发上的伸缩性听起来都很棒，这就让我们进入到了第二章......


不要喝太多#TOCOMPLETE#

本书将会有许多节，名字就如本节一样（当你看到他的时候，你会认出它们的）。在许多热情的演讲的帮助下，Erlang正受到追捧，甚至让人对它抱有过高的期望。这类章节将帮助你回到现实，如果你也是那些过于热心的学徒之一。

第一种上述的情况，是关于Erlang在它轻量级进程的帮助下，容易被大规模扩展的特性。的确，Erlang的进程是非常的轻：你可以同时拥有数以十万记的进程，但这不代表你应该这么做——仅仅是因为你可以。比如，创建一个射击游戏时，把包括子弹在内的所有事物都作为Erlang世界里的演员是不切实际的。在这样设计的游戏里，也许你只能打中自己的脚。演员之间传递消息仍然会有细小的开销，如果你把任务过于细分，那么你会降低执行效率。

在我们学习更加深入，真正需要担心这个问题的时候，我会做出进一步的解释，但是现在，只要知道，在面对问题的时候随意地抛出并行理论，并不能让它变得更快。不要郁闷，总会有机会，让上百个进程成为可能，并且有意义！只不过不总是这样。 #REVIEWME#

Erlang也被认为是运行速度和你系统的CPU核数成正比，但很多时候这并不正确：这是可能的，但很多问题不会让你可以把所有的解决过程同时运行。

这里还有令一样东西需要注意：Erlang做某些事情非常地棒，从技术上而言，其他语言也能达到同样的效果。这句话反过来说也是对的；恰当地考虑每一个问题，然后根据你的判断去选择合适的工具。Erlang不是银弹，它不适合某些特定领域，如图像或信号处理，操作系统设备驱动等，而突出表现在服务器端的大型软件（如，队列，映射-化简（map-reduce))，与其他语言相配合#REVIEWME#，高级协议的实现等。在一些过度领域的表现，则取决于你了。你不需要限制自己把Erlang和服务器端软件绑定：到处都是人们的难以置信的杰作。一个例子是IANO，一个UNICT团队做的机器人，它使用了Erlang来实现它的人工智能，在2009年的欧洲机器人大赛（[Eurobot Competition http://eurobot.dmi.unict.it/])中获得了银奖。另一个例子是Wings 3D，一个开源的3D建模工具（但不用于渲染），它由Erlang实现，并因此得以跨平台。


开始前，你需要准备些什么？

你需要的只是一个文本编辑器和Erlang的环境。你可以从Erlang的官方网站获得源代码和Windows版的二进制包。我不会解释太多安装的细节，但是对于WIndows，仅仅需要下载和运行二进制文件。不要忘记把你的Erlang目录加入你的环境变量PATH中，以便在命令行环境里使用它。

在Debian系的Linux发行版中，你可以通过
{{{
$ apt-get install erlang
}}}
来安装Erlang；而在Fedora（如果你安装了yum），你可以通过
{{{
# yum install erlang
}}}
来达到相同的目的。当然，上述的软件源也许只有旧版本的Erlang包；使用旧版本的Erlang在某些时候，会得到与本教程所描述的不同的结果，并且影响某些程序的性能。因此，我建议你去从源码开始编译。参照包中所包含的README文件，并在Google的帮助下得到所有安装的细节，这些都比我能解释的更好。

如果你使用OSX，我没有什么可以建议的，但是[MacPorts http://macports.org/]可以让你安装到Erlang。（周翀：HomeBrew可以做到同样的事情，轻量级的包管理系统）

注意：在我编写本书的时候，我使用的版本是Erlang R13B+，所以为了得到正确的结果，你应该使用同一或者更新的版本。


哪里可以得到帮助？

这里有几个地方可以获得帮助。如果你使用Linux，你可以使用man命令来看到技术文档。Erlang有一个lists的模块（我们将深入了解）：如果需要lists的文档，只需要输入：
{{{
$ erl -man lists
}}}

在Windows，安装会附带HTML文档。你也可以在任意时间从Erlang官方网站[下载它 http://erlang.org/doc/]，或者在其中一个更加简洁的[替代站点（英文） http://erldocs.com/]阅读它。

当你感觉到自己需要搞清楚所有的东西的时候，可以在[这里 http://www.erlang.se/doc/programming_rules.shtml]找到好的代码实践。这本书的代码也将尽可能去遵从这些规则。

那么，有些时候，仅仅知道技术细节是不够的。当遇到这些情况时，我将主要利用两个的资源：官方[邮件列表 http://erlang.org/faq.html]（你应该订阅它，并从中学习）和[irc.freenode.net]上面的[#erlang irc://irc.freenode.net/erlang]和[#erlang-otp irc://irc.freenode.net/erlang-otp]频道。

哦，如果你是那种，喜欢实例书籍和现成解决方案的人，[trapexit http://trapexit.org/]就是你找的地方。那里也把一些邮件列表转换成论坛和平常wiki的显示形式，这些都很有帮助。

